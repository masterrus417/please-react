import {
  $mobx,
  ObservableMap,
  action,
  allowStateChanges,
  autorun,
  computed,
  createAtom,
  entries,
  extendObservable,
  getAdministration,
  getAtom,
  getGlobalState,
  isAction,
  isComputed,
  isComputedProp,
  isComputingDerivation,
  isObservableArray,
  isObservableMap,
  isObservableObject,
  keys,
  makeObservable,
  observable,
  observe,
  onBecomeUnobserved,
  reaction,
  runInAction,
  transaction,
  values
} from "./chunk-JNSPCPVX.js";
import "./chunk-CEQRFMJQ.js";

// node_modules/mobx-utils/mobx-utils.module.js
var NOOP = function() {
};
var IDENTITY = function(_) {
  return _;
};
function fail(message) {
  throw new Error("[mobx-utils] " + message);
}
function invariant(cond, message) {
  if (message === void 0) {
    message = "Illegal state";
  }
  if (!cond)
    fail(message);
}
function addHiddenProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
var deepFields = function(x) {
  return x && x !== Object.prototype && Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []);
};
var distinctDeepFields = function(x) {
  var deepFieldsIndistinct = deepFields(x);
  var deepFieldsDistinct = deepFieldsIndistinct.filter(function(item, index) {
    return deepFieldsIndistinct.indexOf(item) === index;
  });
  return deepFieldsDistinct;
};
var getAllMethodsAndProperties = function(x) {
  return distinctDeepFields(x).filter(function(name) {
    return name !== "constructor" && !~name.indexOf("__");
  });
};
var PENDING = "pending";
var FULFILLED = "fulfilled";
var REJECTED = "rejected";
function caseImpl(handlers) {
  switch (this.state) {
    case PENDING:
      return handlers.pending && handlers.pending(this.value);
    case REJECTED:
      return handlers.rejected && handlers.rejected(this.value);
    case FULFILLED:
      return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;
  }
}
function fromPromise(origPromise, oldPromise) {
  invariant(arguments.length <= 2, "fromPromise expects up to two arguments");
  invariant(typeof origPromise === "function" || typeof origPromise === "object" && origPromise && typeof origPromise.then === "function", "Please pass a promise or function to fromPromise");
  if (origPromise.isPromiseBasedObservable === true)
    return origPromise;
  if (typeof origPromise === "function") {
    origPromise = new Promise(origPromise);
  }
  var promise = origPromise;
  origPromise.then(action("observableFromPromise-resolve", function(value) {
    promise.value = value;
    promise.state = FULFILLED;
  }), action("observableFromPromise-reject", function(reason) {
    promise.value = reason;
    promise.state = REJECTED;
  }));
  promise.isPromiseBasedObservable = true;
  promise.case = caseImpl;
  var oldData = oldPromise && (oldPromise.state === FULFILLED || oldPromise.state === PENDING) ? oldPromise.value : void 0;
  extendObservable(promise, {
    value: oldData,
    state: PENDING
  }, {}, { deep: false });
  return promise;
}
(function(fromPromise2) {
  fromPromise2.reject = action("fromPromise.reject", function(reason) {
    var p = fromPromise2(Promise.reject(reason));
    p.state = REJECTED;
    p.value = reason;
    return p;
  });
  function resolveBase(value) {
    if (value === void 0) {
      value = void 0;
    }
    var p = fromPromise2(Promise.resolve(value));
    p.state = FULFILLED;
    p.value = value;
    return p;
  }
  fromPromise2.resolve = action("fromPromise.resolve", resolveBase);
})(fromPromise || (fromPromise = {}));
function isPromiseBasedObservable(value) {
  return value && value.isPromiseBasedObservable === true;
}
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
function moveItem(target, fromIndex, toIndex) {
  checkIndex(target, fromIndex);
  checkIndex(target, toIndex);
  if (fromIndex === toIndex) {
    return;
  }
  var oldItems = target.slice();
  var newItems;
  if (fromIndex < toIndex) {
    newItems = __spreadArrays(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [
      oldItems[fromIndex]
    ], oldItems.slice(toIndex + 1));
  } else {
    newItems = __spreadArrays(oldItems.slice(0, toIndex), [
      oldItems[fromIndex]
    ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));
  }
  target.replace(newItems);
  return target;
}
function checkIndex(target, index) {
  if (index < 0) {
    throw new Error("[mobx.array] Index out of bounds: " + index + " is negative");
  }
  var length = target.length;
  if (index >= length) {
    throw new Error("[mobx.array] Index out of bounds: " + index + " is not smaller than " + length);
  }
}
function lazyObservable(fetch, initialValue) {
  if (initialValue === void 0) {
    initialValue = void 0;
  }
  var started = false;
  var value = observable.box(initialValue, { deep: false });
  var pending = observable.box(false);
  var currentFnc = function() {
    if (!started) {
      started = true;
      allowStateChanges(true, function() {
        pending.set(true);
      });
      fetch(function(newValue) {
        allowStateChanges(true, function() {
          value.set(newValue);
          pending.set(false);
        });
      });
    }
    return value.get();
  };
  var resetFnc = action("lazyObservable-reset", function() {
    started = false;
    value.set(initialValue);
    return value.get();
  });
  return {
    current: currentFnc,
    refresh: function() {
      if (started) {
        started = false;
        return currentFnc();
      } else {
        return value.get();
      }
    },
    reset: function() {
      return resetFnc();
    },
    get pending() {
      return pending.get();
    }
  };
}
function fromResource(subscriber, unsubscriber, initialValue) {
  if (unsubscriber === void 0) {
    unsubscriber = NOOP;
  }
  if (initialValue === void 0) {
    initialValue = void 0;
  }
  var isActive = false;
  var isDisposed = false;
  var value = initialValue;
  var suspender = function() {
    if (isActive) {
      isActive = false;
      unsubscriber();
    }
  };
  var atom = createAtom("ResourceBasedObservable", function() {
    invariant(!isActive && !isDisposed);
    isActive = true;
    subscriber(function(newValue) {
      allowStateChanges(true, function() {
        value = newValue;
        atom.reportChanged();
      });
    });
  }, suspender);
  return {
    current: function() {
      invariant(!isDisposed, "subscribingObservable has already been disposed");
      var isBeingTracked = atom.reportObserved();
      if (!isBeingTracked && !isActive)
        console.warn("Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started");
      return value;
    },
    dispose: function() {
      isDisposed = true;
      suspender();
    },
    isAlive: function() {
      return isActive;
    }
  };
}
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function observableSymbol() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}
function toStream(expression, fireImmediately) {
  var _a;
  if (fireImmediately === void 0) {
    fireImmediately = false;
  }
  var computedValue = computed(expression);
  return _a = {
    subscribe: function(observer) {
      if ("function" === typeof observer) {
        return {
          unsubscribe: observe(computedValue, function(_a2) {
            var newValue = _a2.newValue;
            return observer(newValue);
          }, fireImmediately)
        };
      }
      if (observer && "object" === typeof observer && observer.next) {
        return {
          unsubscribe: observe(computedValue, function(_a2) {
            var newValue = _a2.newValue;
            return observer.next(newValue);
          }, fireImmediately)
        };
      }
      return {
        unsubscribe: function() {
        }
      };
    }
  }, _a[observableSymbol()] = function() {
    return this;
  }, _a;
}
var StreamListener = (
  /** @class */
  function() {
    function StreamListener2(observable2, initialValue) {
      var _this = this;
      Object.defineProperty(this, "current", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "subscription", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      makeObservable(this);
      runInAction(function() {
        _this.current = initialValue;
        _this.subscription = observable2.subscribe(_this);
      });
    }
    Object.defineProperty(StreamListener2.prototype, "dispose", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        if (this.subscription) {
          this.subscription.unsubscribe();
        }
      }
    });
    Object.defineProperty(StreamListener2.prototype, "next", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(value) {
        this.current = value;
      }
    });
    Object.defineProperty(StreamListener2.prototype, "complete", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        this.dispose();
      }
    });
    Object.defineProperty(StreamListener2.prototype, "error", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(value) {
        this.current = value;
        this.dispose();
      }
    });
    __decorate([
      observable.ref
    ], StreamListener2.prototype, "current", void 0);
    __decorate([
      action.bound
    ], StreamListener2.prototype, "next", null);
    __decorate([
      action.bound
    ], StreamListener2.prototype, "complete", null);
    __decorate([
      action.bound
    ], StreamListener2.prototype, "error", null);
    return StreamListener2;
  }()
);
function fromStream(observable2, initialValue) {
  if (initialValue === void 0) {
    initialValue = void 0;
  }
  return new StreamListener(observable2, initialValue);
}
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __decorate$1 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RESERVED_NAMES = ["model", "reset", "submit", "isDirty", "isPropertyDirty", "resetProperty"];
var ViewModel = (
  /** @class */
  function() {
    function ViewModel2(model) {
      var _this = this;
      Object.defineProperty(this, "model", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: model
      });
      Object.defineProperty(this, "localValues", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: observable.map({})
      });
      Object.defineProperty(this, "localComputedValues", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: observable.map({})
      });
      Object.defineProperty(this, "isPropertyDirty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function(key) {
          return _this.localValues.has(key);
        }
      });
      makeObservable(this);
      invariant(isObservableObject(model), "createViewModel expects an observable object");
      var ownMethodsAndProperties = getAllMethodsAndProperties(this);
      getAllMethodsAndProperties(model).forEach(function(key) {
        var _a;
        if (ownMethodsAndProperties.includes(key)) {
          return;
        }
        if (key === $mobx || key === "__mobxDidRunLazyInitializers") {
          return;
        }
        invariant(RESERVED_NAMES.indexOf(key) === -1, "The propertyname " + key + " is reserved and cannot be used with viewModels");
        if (isComputedProp(model, key)) {
          var computedBox = getAdministration(model, key);
          var get = computedBox.derivation.bind(_this);
          var set = (_a = computedBox.setter_) === null || _a === void 0 ? void 0 : _a.bind(_this);
          _this.localComputedValues.set(key, computed(get, { set }));
        }
        var descriptor = Object.getOwnPropertyDescriptor(model, key);
        var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};
        Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), { configurable: true, get: function() {
          if (isComputedProp(model, key))
            return _this.localComputedValues.get(key).get();
          if (_this.isPropertyDirty(key))
            return _this.localValues.get(key);
          else
            return _this.model[key];
        }, set: action(function(value) {
          if (isComputedProp(model, key)) {
            _this.localComputedValues.get(key).set(value);
          } else if (value !== _this.model[key]) {
            _this.localValues.set(key, value);
          } else {
            _this.localValues.delete(key);
          }
        }) }));
      });
    }
    Object.defineProperty(ViewModel2.prototype, "isDirty", {
      get: function() {
        return this.localValues.size > 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewModel2.prototype, "changedValues", {
      get: function() {
        return new Map(this.localValues);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewModel2.prototype, "submit", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        var _this = this;
        keys(this.localValues).forEach(function(key) {
          var source = _this.localValues.get(key);
          var destination = _this.model[key];
          if (isObservableArray(destination)) {
            destination.replace(source);
          } else if (isObservableMap(destination)) {
            destination.clear();
            destination.merge(source);
          } else if (!isComputed(source)) {
            _this.model[key] = source;
          }
        });
        this.localValues.clear();
      }
    });
    Object.defineProperty(ViewModel2.prototype, "reset", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        this.localValues.clear();
      }
    });
    Object.defineProperty(ViewModel2.prototype, "resetProperty", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(key) {
        this.localValues.delete(key);
      }
    });
    __decorate$1([
      computed
    ], ViewModel2.prototype, "isDirty", null);
    __decorate$1([
      computed
    ], ViewModel2.prototype, "changedValues", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "submit", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "reset", null);
    __decorate$1([
      action.bound
    ], ViewModel2.prototype, "resetProperty", null);
    return ViewModel2;
  }()
);
function createViewModel(model) {
  return new ViewModel(model);
}
function keepAlive(_1, _2) {
  var computed2 = getAtom(_1, _2);
  if (!computed2)
    throw new Error("No computed provided, please provide an object created with `computed(() => expr)` or an object + property name");
  return observe(computed2, function() {
  });
}
function queueProcessor(observableArray, processor, debounce) {
  if (debounce === void 0) {
    debounce = 0;
  }
  if (!isObservableArray(observableArray))
    throw new Error("Expected observable array as first argument");
  if (!isAction(processor))
    processor = action("queueProcessor", processor);
  var runner = function() {
    var items = observableArray.slice(0);
    runInAction(function() {
      return observableArray.splice(0);
    });
    items.forEach(processor);
  };
  if (debounce > 0)
    return autorun(runner, { delay: debounce });
  else
    return autorun(runner);
}
function chunkProcessor(observableArray, processor, debounce, maxChunkSize) {
  if (debounce === void 0) {
    debounce = 0;
  }
  if (maxChunkSize === void 0) {
    maxChunkSize = 0;
  }
  if (!isObservableArray(observableArray))
    throw new Error("Expected observable array as first argument");
  if (!isAction(processor))
    processor = action("chunkProcessor", processor);
  var runner = function() {
    var _loop_1 = function() {
      var chunkSize = maxChunkSize === 0 ? observableArray.length : Math.min(observableArray.length, maxChunkSize);
      var items = observableArray.slice(0, chunkSize);
      runInAction(function() {
        return observableArray.splice(0, chunkSize);
      });
      processor(items);
    };
    while (observableArray.length > 0) {
      _loop_1();
    }
  };
  if (debounce > 0)
    return autorun(runner, { delay: debounce });
  else
    return autorun(runner);
}
var tickers = {};
function resetNowInternalState() {
  for (var _i = 0, _a = Object.getOwnPropertyNames(tickers); _i < _a.length; _i++) {
    var key = _a[_i];
    tickers[key].dispose();
    delete tickers[key];
  }
}
function now(interval) {
  if (interval === void 0) {
    interval = 1e3;
  }
  if (!isComputingDerivation()) {
    return Date.now();
  }
  if (!tickers[interval]) {
    if (typeof interval === "number")
      tickers[interval] = createIntervalTicker(interval);
    else
      tickers[interval] = createAnimationFrameTicker();
  }
  return tickers[interval].current();
}
function createIntervalTicker(interval) {
  var subscriptionHandle;
  return fromResource(function(sink) {
    sink(Date.now());
    subscriptionHandle = setInterval(function() {
      return sink(Date.now());
    }, interval);
  }, function() {
    clearInterval(subscriptionHandle);
  }, Date.now());
}
function createAnimationFrameTicker() {
  var frameBasedTicker = fromResource(function(sink) {
    sink(Date.now());
    function scheduleTick() {
      window.requestAnimationFrame(function() {
        sink(Date.now());
        if (frameBasedTicker.isAlive())
          scheduleTick();
      });
    }
    scheduleTick();
  }, function() {
  }, Date.now());
  return frameBasedTicker;
}
function expr(expr2) {
  if (!isComputingDerivation())
    console.warn("'expr' should only be used inside other reactive functions.");
  return computed(expr2).get();
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var memoizationId = 0;
function createTransformer(transformer, arg2) {
  invariant(typeof transformer === "function" && transformer.length < 2, "createTransformer expects a function that accepts one argument");
  var views = {};
  var onCleanup = void 0;
  var keepAlive2 = false;
  var debugNameGenerator = void 0;
  if (typeof arg2 === "object") {
    onCleanup = arg2.onCleanup;
    keepAlive2 = arg2.keepAlive !== void 0 ? arg2.keepAlive : false;
    debugNameGenerator = arg2.debugNameGenerator;
  } else if (typeof arg2 === "function") {
    onCleanup = arg2;
  }
  function createView(sourceIdentifier, sourceObject) {
    var latestValue;
    var computedValueOptions = {};
    if (typeof arg2 === "object") {
      onCleanup = arg2.onCleanup;
      debugNameGenerator = arg2.debugNameGenerator;
      computedValueOptions = arg2;
    } else if (typeof arg2 === "function") {
      onCleanup = arg2;
    } else {
      onCleanup = void 0;
      debugNameGenerator = void 0;
    }
    var prettifiedName = debugNameGenerator ? debugNameGenerator(sourceObject) : "Transformer-" + transformer.name + "-" + sourceIdentifier;
    var expr2 = computed(function() {
      return latestValue = transformer(sourceObject);
    }, __assign$1(__assign$1({}, computedValueOptions), { name: prettifiedName }));
    if (!keepAlive2) {
      var disposer_1 = onBecomeUnobserved(expr2, function() {
        delete views[sourceIdentifier];
        disposer_1();
        if (onCleanup)
          onCleanup(latestValue, sourceObject);
      });
    }
    return expr2;
  }
  var memoWarned = false;
  return function(object) {
    var identifier = getMemoizationId(object);
    var reactiveView = views[identifier];
    if (reactiveView)
      return reactiveView.get();
    if (!keepAlive2 && !isComputingDerivation()) {
      if (!memoWarned) {
        console.warn("invoking a transformer from outside a reactive context won't memorized and is cleaned up immediately, unless keepAlive is set");
        memoWarned = true;
      }
      var value = transformer(object);
      if (onCleanup)
        onCleanup(value, object);
      return value;
    }
    reactiveView = views[identifier] = createView(identifier, object);
    return reactiveView.get();
  };
}
function getMemoizationId(object) {
  var objectType = typeof object;
  if (objectType === "string")
    return "string:" + object;
  if (objectType === "number")
    return "number:" + object;
  if (object === null || objectType !== "object" && objectType !== "function")
    throw new Error("[mobx-utils] transform expected an object, function, string or number, got: " + String(object));
  var tid = object.$transformId;
  if (tid === void 0) {
    tid = "memoizationId:" + ++memoizationId;
    addHiddenProp(object, "$transformId", tid);
  }
  return tid;
}
function buildPath(entry) {
  if (!entry)
    return "ROOT";
  var res = [];
  while (entry.parent) {
    res.push(entry.path);
    entry = entry.parent;
  }
  return res.reverse().join("/");
}
function isRecursivelyObservable(thing) {
  return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);
}
function deepObserve(target, listener) {
  var entrySet = /* @__PURE__ */ new WeakMap();
  function genericListener(change) {
    var entry = entrySet.get(change.object);
    processChange(change, entry);
    listener(change, buildPath(entry), target);
  }
  function processChange(change, parent) {
    switch (change.type) {
      case "add":
        observeRecursively(change.newValue, parent, change.name);
        break;
      case "update":
        unobserveRecursively(change.oldValue);
        observeRecursively(change.newValue, parent, change.name || "" + change.index);
        break;
      case "remove":
      case "delete":
        unobserveRecursively(change.oldValue);
        break;
      case "splice":
        change.removed.map(unobserveRecursively);
        change.added.forEach(function(value, idx) {
          return observeRecursively(value, parent, "" + (change.index + idx));
        });
        for (var i = change.index + change.addedCount; i < change.object.length; i++) {
          if (isRecursivelyObservable(change.object[i])) {
            var entry = entrySet.get(change.object[i]);
            if (entry)
              entry.path = "" + i;
          }
        }
        break;
    }
  }
  function observeRecursively(thing, parent, path) {
    if (isRecursivelyObservable(thing)) {
      var entry = entrySet.get(thing);
      if (entry) {
        if (entry.parent !== parent || entry.path !== path)
          throw new Error("The same observable object cannot appear twice in the same tree," + (" trying to assign it to '" + buildPath(parent) + "/" + path + "',") + (" but it already exists at '" + buildPath(entry.parent) + "/" + entry.path + "'"));
      } else {
        var entry_1 = {
          parent,
          path,
          dispose: observe(thing, genericListener)
        };
        entrySet.set(thing, entry_1);
        entries(thing).forEach(function(_a) {
          var key = _a[0], value = _a[1];
          return observeRecursively(value, entry_1, key);
        });
      }
    }
  }
  function unobserveRecursively(thing) {
    if (isRecursivelyObservable(thing)) {
      var entry = entrySet.get(thing);
      if (!entry)
        return;
      entrySet.delete(thing);
      entry.dispose();
      values(thing).forEach(unobserveRecursively);
    }
  }
  observeRecursively(target, void 0, "");
  return function() {
    unobserveRecursively(target);
  };
}
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ObservableGroupMap = (
  /** @class */
  function(_super) {
    __extends(ObservableGroupMap2, _super);
    function ObservableGroupMap2(base, groupBy, _a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? "ogm" + (Math.random() * 1e3 | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function(x) {
        return "" + x;
      } : _d;
      var _this = _super.call(this) || this;
      Object.defineProperty(_this, "_base", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(_this, "_ogmInfoKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(_this, "_groupBy", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(_this, "_keyToName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(_this, "_disposeBaseObserver", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      _this._keyToName = keyToName;
      _this._groupBy = groupBy;
      _this._ogmInfoKey = Symbol("ogmInfo" + name);
      _this._base = base;
      for (var i = 0; i < base.length; i++) {
        _this._addItem(base[i]);
      }
      _this._disposeBaseObserver = observe(_this._base, function(change) {
        if ("splice" === change.type) {
          transaction(function() {
            for (var _i = 0, _a2 = change.removed; _i < _a2.length; _i++) {
              var removed = _a2[_i];
              _this._removeItem(removed);
            }
            for (var _b2 = 0, _c2 = change.added; _b2 < _c2.length; _b2++) {
              var added = _c2[_b2];
              _this._addItem(added);
            }
          });
        } else if ("update" === change.type) {
          transaction(function() {
            _this._removeItem(change.oldValue);
            _this._addItem(change.newValue);
          });
        } else {
          throw new Error("illegal state");
        }
      });
      return _this;
    }
    Object.defineProperty(ObservableGroupMap2.prototype, "clear", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        throw new Error("not supported");
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "delete", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(_key) {
        throw new Error("not supported");
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "set", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(_key, _value) {
        throw new Error("not supported");
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "dispose", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        this._disposeBaseObserver();
        for (var i = 0; i < this._base.length; i++) {
          var item = this._base[i];
          var grouperItemInfo = item[this._ogmInfoKey];
          grouperItemInfo.reaction();
          delete item[this._ogmInfoKey];
        }
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "_getGroupArr", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(key) {
        var result = _super.prototype.get.call(this, key);
        if (void 0 === result) {
          result = observable([], { name: "GroupArray[" + this._keyToName(key) + "]", deep: false });
          _super.prototype.set.call(this, key, result);
        }
        return result;
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "_removeFromGroupArr", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(key, itemIndex) {
        var arr = _super.prototype.get.call(this, key);
        if (1 === arr.length) {
          _super.prototype.delete.call(this, key);
        } else if (itemIndex === arr.length - 1) {
          arr.length--;
        } else {
          arr[itemIndex] = arr[arr.length - 1];
          arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;
          arr.length--;
        }
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "_addItem", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(item) {
        var _this = this;
        var groupByValue = this._groupBy(item);
        var groupArr = this._getGroupArr(groupByValue);
        var value = {
          groupByValue,
          groupArrIndex: groupArr.length,
          reaction: reaction(function() {
            return _this._groupBy(item);
          }, function(newGroupByValue, _r) {
            var grouperItemInfo = item[_this._ogmInfoKey];
            _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);
            var newGroupArr = _this._getGroupArr(newGroupByValue);
            var newGroupArrIndex = newGroupArr.length;
            newGroupArr.push(item);
            grouperItemInfo.groupByValue = newGroupByValue;
            grouperItemInfo.groupArrIndex = newGroupArrIndex;
          })
        };
        Object.defineProperty(item, this._ogmInfoKey, {
          configurable: true,
          enumerable: false,
          value
        });
        groupArr.push(item);
      }
    });
    Object.defineProperty(ObservableGroupMap2.prototype, "_removeItem", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(item) {
        var grouperItemInfo = item[this._ogmInfoKey];
        this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);
        grouperItemInfo.reaction();
        delete item[this._ogmInfoKey];
      }
    });
    return ObservableGroupMap2;
  }(ObservableMap)
);
var DeepMapEntry = (
  /** @class */
  function() {
    function DeepMapEntry2(base, args) {
      Object.defineProperty(this, "base", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: base
      });
      Object.defineProperty(this, "args", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: args
      });
      Object.defineProperty(this, "root", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "closest", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "closestIdx", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
      });
      Object.defineProperty(this, "isDisposed", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      var current = this.closest = this.root = base;
      var i = 0;
      for (; i < this.args.length - 1; i++) {
        current = current.get(args[i]);
        if (current)
          this.closest = current;
        else
          break;
      }
      this.closestIdx = i;
    }
    Object.defineProperty(DeepMapEntry2.prototype, "exists", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        this.assertNotDisposed();
        var l = this.args.length;
        return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]);
      }
    });
    Object.defineProperty(DeepMapEntry2.prototype, "get", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        this.assertNotDisposed();
        if (!this.exists())
          throw new Error("Entry doesn't exist");
        return this.closest.get(this.args[this.args.length - 1]);
      }
    });
    Object.defineProperty(DeepMapEntry2.prototype, "set", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(value) {
        this.assertNotDisposed();
        var l = this.args.length;
        var current = this.closest;
        for (var i = this.closestIdx; i < l - 1; i++) {
          var m = /* @__PURE__ */ new Map();
          current.set(this.args[i], m);
          current = m;
        }
        this.closestIdx = l - 1;
        this.closest = current;
        current.set(this.args[l - 1], value);
      }
    });
    Object.defineProperty(DeepMapEntry2.prototype, "delete", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        this.assertNotDisposed();
        if (!this.exists())
          throw new Error("Entry doesn't exist");
        var l = this.args.length;
        this.closest.delete(this.args[l - 1]);
        var c = this.root;
        var maps = [c];
        for (var i = 0; i < l - 1; i++) {
          c = c.get(this.args[i]);
          maps.push(c);
        }
        for (var i = maps.length - 1; i > 0; i--) {
          if (maps[i].size === 0)
            maps[i - 1].delete(this.args[i - 1]);
        }
        this.isDisposed = true;
      }
    });
    Object.defineProperty(DeepMapEntry2.prototype, "assertNotDisposed", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        if (this.isDisposed)
          throw new Error("Concurrent modification exception");
      }
    });
    return DeepMapEntry2;
  }()
);
var DeepMap = (
  /** @class */
  function() {
    function DeepMap2() {
      Object.defineProperty(this, "store", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "argsLength", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -1
      });
      Object.defineProperty(this, "last", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
    }
    Object.defineProperty(DeepMap2.prototype, "entry", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(args) {
        if (this.argsLength === -1)
          this.argsLength = args.length;
        else if (this.argsLength !== args.length)
          throw new Error("DeepMap should be used with functions with a consistent length, expected: " + this.argsLength + ", got: " + args.length);
        if (this.last)
          this.last.isDisposed = true;
        return this.last = new DeepMapEntry(this.store, args);
      }
    });
    return DeepMap2;
  }()
);
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
var __spreadArrays$1 = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
function computedFn(fn, keepAliveOrOptions) {
  if (keepAliveOrOptions === void 0) {
    keepAliveOrOptions = false;
  }
  if (isAction(fn))
    throw new Error("computedFn shouldn't be used on actions");
  var memoWarned = false;
  var i = 0;
  var opts = typeof keepAliveOrOptions === "boolean" ? { keepAlive: keepAliveOrOptions } : keepAliveOrOptions;
  var d = new DeepMap();
  return function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var entry = d.entry(args);
    if (entry.exists())
      return entry.get().get();
    if (!opts.keepAlive && !isComputingDerivation()) {
      if (!memoWarned && getGlobalState().computedRequiresReaction) {
        console.warn("invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set");
        memoWarned = true;
      }
      return fn.apply(this, args);
    }
    var latestValue;
    var c = computed(function() {
      return latestValue = fn.apply(_this, args);
    }, __assign$2(__assign$2({}, opts), { name: "computedFn(" + (opts.name || fn.name) + "#" + ++i + ")" }));
    entry.set(c);
    if (!opts.keepAlive)
      onBecomeUnobserved(c, function() {
        d.entry(args).delete();
        if (opts.onCleanup)
          opts.onCleanup.apply(opts, __spreadArrays$1([latestValue], args));
        latestValue = void 0;
      });
    return c.get();
  };
}
export {
  FULFILLED,
  IDENTITY,
  NOOP,
  ObservableGroupMap,
  PENDING,
  REJECTED,
  ViewModel,
  addHiddenProp,
  chunkProcessor,
  computedFn,
  createTransformer,
  createViewModel,
  deepObserve,
  expr,
  fail,
  fromPromise,
  fromResource,
  fromStream,
  getAllMethodsAndProperties,
  invariant,
  isPromiseBasedObservable,
  keepAlive,
  lazyObservable,
  moveItem,
  now,
  queueProcessor,
  resetNowInternalState,
  toStream
};
//# sourceMappingURL=mobx-utils.js.map
