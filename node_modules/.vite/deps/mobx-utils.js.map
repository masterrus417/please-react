{
  "version": 3,
  "sources": ["../../mobx-utils/mobx-utils.module.js"],
  "sourcesContent": ["import { action, extendObservable, observable, _allowStateChanges, createAtom, computed, observe, makeObservable, runInAction, keys, isObservableArray, isObservableMap, isComputed, isObservableObject, $mobx, isComputedProp, _getAdministration, getAtom, isAction, autorun, _isComputingDerivation, onBecomeUnobserved, entries, values, transaction, reaction, ObservableMap, _getGlobalState } from 'mobx';\n\nvar NOOP = function () { };\r\nvar IDENTITY = function (_) { return _; };\r\nfunction fail(message) {\r\n    throw new Error(\"[mobx-utils] \" + message);\r\n}\r\nfunction invariant(cond, message) {\r\n    if (message === void 0) { message = \"Illegal state\"; }\r\n    if (!cond)\r\n        fail(message);\r\n}\r\nfunction addHiddenProp(object, propName, value) {\r\n    Object.defineProperty(object, propName, {\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true,\r\n        value: value,\r\n    });\r\n}\r\nvar deepFields = function (x) {\r\n    return (x &&\r\n        x !== Object.prototype &&\r\n        Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []));\r\n};\r\nvar distinctDeepFields = function (x) {\r\n    var deepFieldsIndistinct = deepFields(x);\r\n    var deepFieldsDistinct = deepFieldsIndistinct.filter(function (item, index) { return deepFieldsIndistinct.indexOf(item) === index; });\r\n    return deepFieldsDistinct;\r\n};\r\nvar getAllMethodsAndProperties = function (x) {\r\n    return distinctDeepFields(x).filter(function (name) { return name !== \"constructor\" && !~name.indexOf(\"__\"); });\r\n};\n\nvar PENDING = \"pending\";\r\nvar FULFILLED = \"fulfilled\";\r\nvar REJECTED = \"rejected\";\r\nfunction caseImpl(handlers) {\r\n    switch (this.state) {\r\n        case PENDING:\r\n            return handlers.pending && handlers.pending(this.value);\r\n        case REJECTED:\r\n            return handlers.rejected && handlers.rejected(this.value);\r\n        case FULFILLED:\r\n            return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;\r\n    }\r\n}\r\n/**\r\n * `fromPromise` takes a Promise, extends it with 2 observable properties that track\r\n * the status of the promise and returns it. The returned object has the following observable properties:\r\n *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.\r\n *  - `state`: one of `\"pending\"`, `\"fulfilled\"` or `\"rejected\"`\r\n *\r\n * And the following methods:\r\n * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.\r\n *\r\n * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.\r\n *\r\n * Note that the status strings are available as constants:\r\n * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`\r\n *\r\n * fromPromise takes an optional second argument, a previously created `fromPromise` based observable.\r\n * This is useful to replace one promise based observable with another, without going back to an intermediate\r\n * \"pending\" promise state while fetching data. For example:\r\n *\r\n * @example\r\n * \\@observer\r\n * class SearchResults extends React.Component {\r\n *   \\@observable.ref searchResults\r\n *\r\n *   componentDidUpdate(nextProps) {\r\n *     if (nextProps.query !== this.props.query)\r\n *       this.searchResults = fromPromise(\r\n *         window.fetch(\"/search?q=\" + nextProps.query),\r\n *         // by passing, we won't render a pending state if we had a successful search query before\r\n *         // rather, we will keep showing the previous search results, until the new promise resolves (or rejects)\r\n *         this.searchResults\r\n *       )\r\n *   }\r\n *\r\n *   render() {\r\n *     return this.searchResults.case({\r\n *        pending: (staleValue) => {\r\n *          return staleValue || \"searching\" // <- value might set to previous results while the promise is still pending\r\n *        },\r\n *        fulfilled: (value) => {\r\n *          return value // the fresh results\r\n *        },\r\n *        rejected: (error) => {\r\n *          return \"Oops: \" + error\r\n *        }\r\n *     })\r\n *   }\r\n * }\r\n *\r\n * Observable promises can be created immediately in a certain state using\r\n * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.\r\n * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.\r\n *\r\n * It is possible to directly create a promise using a resolve, reject function:\r\n * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`\r\n *\r\n * @example\r\n * const fetchResult = fromPromise(fetch(\"http://someurl\"))\r\n *\r\n * // combine with when..\r\n * when(\r\n *   () => fetchResult.state !== \"pending\",\r\n *   () => {\r\n *     console.log(\"Got \", fetchResult.value)\r\n *   }\r\n * )\r\n *\r\n * // or a mobx-react component..\r\n * const myComponent = observer(({ fetchResult }) => {\r\n *   switch(fetchResult.state) {\r\n *      case \"pending\": return <div>Loading...</div>\r\n *      case \"rejected\": return <div>Ooops... {fetchResult.value}</div>\r\n *      case \"fulfilled\": return <div>Gotcha: {fetchResult.value}</div>\r\n *   }\r\n * })\r\n *\r\n * // or using the case method instead of switch:\r\n *\r\n * const myComponent = observer(({ fetchResult }) =>\r\n *   fetchResult.case({\r\n *     pending:   () => <div>Loading...</div>,\r\n *     rejected:  error => <div>Ooops.. {error}</div>,\r\n *     fulfilled: value => <div>Gotcha: {value}</div>,\r\n *   }))\r\n *\r\n * // chain additional handler(s) to the resolve/reject:\r\n *\r\n * fetchResult.then(\r\n *   (result) =>  doSomeTransformation(result),\r\n *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)\r\n * ).then(\r\n *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)\r\n * )\r\n *\r\n * @param origPromise The promise which will be observed\r\n * @param oldPromise The previously observed promise\r\n * @returns origPromise with added properties and methods described above.\r\n */\r\nfunction fromPromise(origPromise, oldPromise) {\r\n    invariant(arguments.length <= 2, \"fromPromise expects up to two arguments\");\r\n    invariant(typeof origPromise === \"function\" ||\r\n        (typeof origPromise === \"object\" &&\r\n            origPromise &&\r\n            typeof origPromise.then === \"function\"), \"Please pass a promise or function to fromPromise\");\r\n    if (origPromise.isPromiseBasedObservable === true)\r\n        return origPromise;\r\n    if (typeof origPromise === \"function\") {\r\n        // If it is a (reject, resolve function, wrap it)\r\n        origPromise = new Promise(origPromise);\r\n    }\r\n    var promise = origPromise;\r\n    origPromise.then(action(\"observableFromPromise-resolve\", function (value) {\r\n        promise.value = value;\r\n        promise.state = FULFILLED;\r\n    }), action(\"observableFromPromise-reject\", function (reason) {\r\n        promise.value = reason;\r\n        promise.state = REJECTED;\r\n    }));\r\n    promise.isPromiseBasedObservable = true;\r\n    promise.case = caseImpl;\r\n    var oldData = oldPromise && (oldPromise.state === FULFILLED || oldPromise.state === PENDING)\r\n        ? oldPromise.value\r\n        : undefined;\r\n    extendObservable(promise, {\r\n        value: oldData,\r\n        state: PENDING,\r\n    }, {}, { deep: false });\r\n    return promise;\r\n}\r\n(function (fromPromise) {\r\n    fromPromise.reject = action(\"fromPromise.reject\", function (reason) {\r\n        var p = fromPromise(Promise.reject(reason));\r\n        p.state = REJECTED;\r\n        p.value = reason;\r\n        return p;\r\n    });\r\n    function resolveBase(value) {\r\n        if (value === void 0) { value = undefined; }\r\n        var p = fromPromise(Promise.resolve(value));\r\n        p.state = FULFILLED;\r\n        p.value = value;\r\n        return p;\r\n    }\r\n    fromPromise.resolve = action(\"fromPromise.resolve\", resolveBase);\r\n})(fromPromise || (fromPromise = {}));\r\n/**\r\n * Returns true if the provided value is a promise-based observable.\r\n * @param value any\r\n * @returns {boolean}\r\n */\r\nfunction isPromiseBasedObservable(value) {\r\n    return value && value.isPromiseBasedObservable === true;\r\n}\n\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n/**\r\n * Moves an item from one position to another, checking that the indexes given are within bounds.\r\n *\r\n * @example\r\n * const source = observable([1, 2, 3])\r\n * moveItem(source, 0, 1)\r\n * console.log(source.map(x => x)) // [2, 1, 3]\r\n *\r\n * @export\r\n * @param {ObservableArray<T>} target\r\n * @param {number} fromIndex\r\n * @param {number} toIndex\r\n * @returns {ObservableArray<T>}\r\n */\r\nfunction moveItem(target, fromIndex, toIndex) {\r\n    checkIndex(target, fromIndex);\r\n    checkIndex(target, toIndex);\r\n    if (fromIndex === toIndex) {\r\n        return;\r\n    }\r\n    var oldItems = target.slice();\r\n    var newItems;\r\n    if (fromIndex < toIndex) {\r\n        newItems = __spreadArrays(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [\r\n            oldItems[fromIndex]\r\n        ], oldItems.slice(toIndex + 1));\r\n    }\r\n    else {\r\n        // toIndex < fromIndex\r\n        newItems = __spreadArrays(oldItems.slice(0, toIndex), [\r\n            oldItems[fromIndex]\r\n        ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\r\n    }\r\n    target.replace(newItems);\r\n    return target;\r\n}\r\n/**\r\n * Checks whether the specified index is within bounds. Throws if not.\r\n *\r\n * @private\r\n * @param {ObservableArray<any>} target\r\n * @param {number }index\r\n */\r\nfunction checkIndex(target, index) {\r\n    if (index < 0) {\r\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\r\n    }\r\n    var length = target.length;\r\n    if (index >= length) {\r\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\r\n    }\r\n}\n\n/**\r\n * `lazyObservable` creates an observable around a `fetch` method that will not be invoked\r\n * until the observable is needed the first time.\r\n * The fetch method receives a `sink` callback which can be used to replace the\r\n * current value of the lazyObservable. It is allowed to call `sink` multiple times\r\n * to keep the lazyObservable up to date with some external resource.\r\n *\r\n * Note that it is the `current()` call itself which is being tracked by MobX,\r\n * so make sure that you don't dereference to early.\r\n *\r\n * @example\r\n * const userProfile = lazyObservable(\r\n *   sink => fetch(\"/myprofile\").then(profile => sink(profile))\r\n * )\r\n *\r\n * // use the userProfile in a React component:\r\n * const Profile = observer(({ userProfile }) =>\r\n *   userProfile.current() === undefined\r\n *   ? <div>Loading user profile...</div>\r\n *   : <div>{userProfile.current().displayName}</div>\r\n * )\r\n *\r\n * // triggers refresh the userProfile\r\n * userProfile.refresh()\r\n *\r\n * @param {(sink: (newValue: T) => void) => void} fetch method that will be called the first time the value of this observable is accessed. The provided sink can be used to produce a new value, synchronously or asynchronously\r\n * @param {T} [initialValue=undefined] optional initialValue that will be returned from `current` as long as the `sink` has not been called at least once\r\n * @returns {{\r\n *     current(): T,\r\n *     refresh(): T,\r\n *     reset(): T\r\n *     pending: boolean\r\n * }}\r\n */\r\nfunction lazyObservable(fetch, initialValue) {\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    var started = false;\r\n    var value = observable.box(initialValue, { deep: false });\r\n    var pending = observable.box(false);\r\n    var currentFnc = function () {\r\n        if (!started) {\r\n            started = true;\r\n            _allowStateChanges(true, function () {\r\n                pending.set(true);\r\n            });\r\n            fetch(function (newValue) {\r\n                _allowStateChanges(true, function () {\r\n                    value.set(newValue);\r\n                    pending.set(false);\r\n                });\r\n            });\r\n        }\r\n        return value.get();\r\n    };\r\n    var resetFnc = action(\"lazyObservable-reset\", function () {\r\n        started = false;\r\n        value.set(initialValue);\r\n        return value.get();\r\n    });\r\n    return {\r\n        current: currentFnc,\r\n        refresh: function () {\r\n            if (started) {\r\n                started = false;\r\n                return currentFnc();\r\n            }\r\n            else {\r\n                return value.get();\r\n            }\r\n        },\r\n        reset: function () {\r\n            return resetFnc();\r\n        },\r\n        get pending() {\r\n            return pending.get();\r\n        },\r\n    };\r\n}\n\n/**\r\n * `fromResource` creates an observable whose current state can be inspected using `.current()`,\r\n * and which can be kept in sync with some external datasource that can be subscribed to.\r\n *\r\n * The created observable will only subscribe to the datasource if it is in use somewhere,\r\n * (un)subscribing when needed. To enable `fromResource` to do that two callbacks need to be provided,\r\n * one to subscribe, and one to unsubscribe. The subscribe callback itself will receive a `sink` callback, which can be used\r\n * to update the current state of the observable, allowing observes to react.\r\n *\r\n * Whatever is passed to `sink` will be returned by `current()`. The values passed to the sink will not be converted to\r\n * observables automatically, but feel free to do so.\r\n * It is the `current()` call itself which is being tracked,\r\n * so make sure that you don't dereference to early.\r\n *\r\n * For inspiration, an example integration with the apollo-client on [github](https://github.com/apollostack/apollo-client/issues/503#issuecomment-241101379),\r\n * or the [implementation](https://github.com/mobxjs/mobx-utils/blob/1d17cf7f7f5200937f68cc0b5e7ec7f3f71dccba/src/now.ts#L43-L57) of `mobxUtils.now`\r\n *\r\n * The following example code creates an observable that connects to a `dbUserRecord`,\r\n * which comes from an imaginary database and notifies when it has changed.\r\n *\r\n * @example\r\n * function createObservableUser(dbUserRecord) {\r\n *   let currentSubscription;\r\n *   return fromResource(\r\n *     (sink) => {\r\n *       // sink the current state\r\n *       sink(dbUserRecord.fields)\r\n *       // subscribe to the record, invoke the sink callback whenever new data arrives\r\n *       currentSubscription = dbUserRecord.onUpdated(() => {\r\n *         sink(dbUserRecord.fields)\r\n *       })\r\n *     },\r\n *     () => {\r\n *       // the user observable is not in use at the moment, unsubscribe (for now)\r\n *       dbUserRecord.unsubscribe(currentSubscription)\r\n *     }\r\n *   )\r\n * }\r\n *\r\n * // usage:\r\n * const myUserObservable = createObservableUser(myDatabaseConnector.query(\"name = 'Michel'\"))\r\n *\r\n * // use the observable in autorun\r\n * autorun(() => {\r\n *   // printed everytime the database updates its records\r\n *   console.log(myUserObservable.current().displayName)\r\n * })\r\n *\r\n * // ... or a component\r\n * const userComponent = observer(({ user }) =>\r\n *   <div>{user.current().displayName}</div>\r\n * )\r\n *\r\n * @export\r\n * @template T\r\n * @param {(sink: (newValue: T) => void) => void} subscriber\r\n * @param {IDisposer} [unsubscriber=NOOP]\r\n * @param {T} [initialValue=undefined] the data that will be returned by `get()` until the `sink` has emitted its first data\r\n * @returns {{\r\n *     current(): T;\r\n *     dispose(): void;\r\n *     isAlive(): boolean;\r\n * }}\r\n */\r\nfunction fromResource(subscriber, unsubscriber, initialValue) {\r\n    if (unsubscriber === void 0) { unsubscriber = NOOP; }\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    var isActive = false;\r\n    var isDisposed = false;\r\n    var value = initialValue;\r\n    var suspender = function () {\r\n        if (isActive) {\r\n            isActive = false;\r\n            unsubscriber();\r\n        }\r\n    };\r\n    var atom = createAtom(\"ResourceBasedObservable\", function () {\r\n        invariant(!isActive && !isDisposed);\r\n        isActive = true;\r\n        subscriber(function (newValue) {\r\n            _allowStateChanges(true, function () {\r\n                value = newValue;\r\n                atom.reportChanged();\r\n            });\r\n        });\r\n    }, suspender);\r\n    return {\r\n        current: function () {\r\n            invariant(!isDisposed, \"subscribingObservable has already been disposed\");\r\n            var isBeingTracked = atom.reportObserved();\r\n            if (!isBeingTracked && !isActive)\r\n                console.warn(\"Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started\");\r\n            return value;\r\n        },\r\n        dispose: function () {\r\n            isDisposed = true;\r\n            suspender();\r\n        },\r\n        isAlive: function () { return isActive; },\r\n    };\r\n}\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nfunction observableSymbol() {\r\n    return (typeof Symbol === \"function\" && Symbol.observable) || \"@@observable\";\r\n}\r\n/**\r\n * Converts an expression to an observable stream (a.k.a. TC 39 Observable / RxJS observable).\r\n * The provided expression is tracked by mobx as long as there are subscribers, automatically\r\n * emitting when new values become available. The expressions respect (trans)actions.\r\n *\r\n * @example\r\n *\r\n * const user = observable({\r\n *   firstName: \"C.S\",\r\n *   lastName: \"Lewis\"\r\n * })\r\n *\r\n * Rx.Observable\r\n *   .from(mobxUtils.toStream(() => user.firstname + user.lastName))\r\n *   .scan(nameChanges => nameChanges + 1, 0)\r\n *   .subscribe(nameChanges => console.log(\"Changed name \", nameChanges, \"times\"))\r\n *\r\n * @export\r\n * @template T\r\n * @param {() => T} expression\r\n * @param {boolean} fireImmediately (by default false)\r\n * @returns {IObservableStream<T>}\r\n */\r\nfunction toStream(expression, fireImmediately) {\r\n    var _a;\r\n    if (fireImmediately === void 0) { fireImmediately = false; }\r\n    var computedValue = computed(expression);\r\n    return _a = {\r\n            subscribe: function (observer) {\r\n                if (\"function\" === typeof observer) {\r\n                    return {\r\n                        unsubscribe: observe(computedValue, function (_a) {\r\n                            var newValue = _a.newValue;\r\n                            return observer(newValue);\r\n                        }, fireImmediately),\r\n                    };\r\n                }\r\n                if (observer && \"object\" === typeof observer && observer.next) {\r\n                    return {\r\n                        unsubscribe: observe(computedValue, function (_a) {\r\n                            var newValue = _a.newValue;\r\n                            return observer.next(newValue);\r\n                        }, fireImmediately),\r\n                    };\r\n                }\r\n                return {\r\n                    unsubscribe: function () { },\r\n                };\r\n            }\r\n        },\r\n        _a[observableSymbol()] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\r\nvar StreamListener = /** @class */ (function () {\r\n    function StreamListener(observable, initialValue) {\r\n        var _this = this;\r\n        Object.defineProperty(this, \"current\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"subscription\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        makeObservable(this);\r\n        runInAction(function () {\r\n            _this.current = initialValue;\r\n            _this.subscription = observable.subscribe(_this);\r\n        });\r\n    }\r\n    Object.defineProperty(StreamListener.prototype, \"dispose\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            if (this.subscription) {\r\n                this.subscription.unsubscribe();\r\n            }\r\n        }\r\n    });\r\n    Object.defineProperty(StreamListener.prototype, \"next\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (value) {\r\n            this.current = value;\r\n        }\r\n    });\r\n    Object.defineProperty(StreamListener.prototype, \"complete\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this.dispose();\r\n        }\r\n    });\r\n    Object.defineProperty(StreamListener.prototype, \"error\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (value) {\r\n            this.current = value;\r\n            this.dispose();\r\n        }\r\n    });\r\n    __decorate([\r\n        observable.ref\r\n    ], StreamListener.prototype, \"current\", void 0);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"next\", null);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"complete\", null);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"error\", null);\r\n    return StreamListener;\r\n}());\r\nfunction fromStream(observable, initialValue) {\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    return new StreamListener(observable, initialValue);\r\n}\n\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar RESERVED_NAMES = [\"model\", \"reset\", \"submit\", \"isDirty\", \"isPropertyDirty\", \"resetProperty\"];\r\nvar ViewModel = /** @class */ (function () {\r\n    function ViewModel(model) {\r\n        var _this = this;\r\n        Object.defineProperty(this, \"model\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: model\r\n        });\r\n        Object.defineProperty(this, \"localValues\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: observable.map({})\r\n        });\r\n        Object.defineProperty(this, \"localComputedValues\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: observable.map({})\r\n        });\r\n        Object.defineProperty(this, \"isPropertyDirty\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: function (key) {\r\n                return _this.localValues.has(key);\r\n            }\r\n        });\r\n        makeObservable(this);\r\n        invariant(isObservableObject(model), \"createViewModel expects an observable object\");\r\n        var ownMethodsAndProperties = getAllMethodsAndProperties(this);\r\n        // use this helper as Object.getOwnPropertyNames doesn't return getters\r\n        getAllMethodsAndProperties(model).forEach(function (key) {\r\n            var _a;\r\n            if (ownMethodsAndProperties.includes(key)) {\r\n                return;\r\n            }\r\n            if (key === $mobx || key === \"__mobxDidRunLazyInitializers\") {\r\n                return;\r\n            }\r\n            invariant(RESERVED_NAMES.indexOf(key) === -1, \"The propertyname \" + key + \" is reserved and cannot be used with viewModels\");\r\n            if (isComputedProp(model, key)) {\r\n                var computedBox = _getAdministration(model, key); // Fixme: there is no clear api to get the derivation\r\n                var get = computedBox.derivation.bind(_this);\r\n                var set = (_a = computedBox.setter_) === null || _a === void 0 ? void 0 : _a.bind(_this);\r\n                _this.localComputedValues.set(key, computed(get, { set: set }));\r\n            }\r\n            var descriptor = Object.getOwnPropertyDescriptor(model, key);\r\n            var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};\r\n            Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), { configurable: true, get: function () {\r\n                    if (isComputedProp(model, key))\r\n                        return _this.localComputedValues.get(key).get();\r\n                    if (_this.isPropertyDirty(key))\r\n                        return _this.localValues.get(key);\r\n                    else\r\n                        return _this.model[key];\r\n                }, set: action(function (value) {\r\n                    if (isComputedProp(model, key)) {\r\n                        _this.localComputedValues.get(key).set(value);\r\n                    }\r\n                    else if (value !== _this.model[key]) {\r\n                        _this.localValues.set(key, value);\r\n                    }\r\n                    else {\r\n                        _this.localValues.delete(key);\r\n                    }\r\n                }) }));\r\n        });\r\n    }\r\n    Object.defineProperty(ViewModel.prototype, \"isDirty\", {\r\n        get: function () {\r\n            return this.localValues.size > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewModel.prototype, \"changedValues\", {\r\n        get: function () {\r\n            return new Map(this.localValues);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewModel.prototype, \"submit\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            var _this = this;\r\n            keys(this.localValues).forEach(function (key) {\r\n                var source = _this.localValues.get(key);\r\n                var destination = _this.model[key];\r\n                if (isObservableArray(destination)) {\r\n                    destination.replace(source);\r\n                }\r\n                else if (isObservableMap(destination)) {\r\n                    destination.clear();\r\n                    destination.merge(source);\r\n                }\r\n                else if (!isComputed(source)) {\r\n                    _this.model[key] = source;\r\n                }\r\n            });\r\n            this.localValues.clear();\r\n        }\r\n    });\r\n    Object.defineProperty(ViewModel.prototype, \"reset\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this.localValues.clear();\r\n        }\r\n    });\r\n    Object.defineProperty(ViewModel.prototype, \"resetProperty\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (key) {\r\n            this.localValues.delete(key);\r\n        }\r\n    });\r\n    __decorate$1([\r\n        computed\r\n    ], ViewModel.prototype, \"isDirty\", null);\r\n    __decorate$1([\r\n        computed\r\n    ], ViewModel.prototype, \"changedValues\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"submit\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"reset\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"resetProperty\", null);\r\n    return ViewModel;\r\n}());\r\n/**\r\n * `createViewModel` takes an object with observable properties (model)\r\n * and wraps a viewmodel around it. The viewmodel proxies all enumerable properties of the original model with the following behavior:\r\n *  - as long as no new value has been assigned to the viewmodel property, the original property will be returned.\r\n *  - any future change in the model will be visible in the viewmodel as well unless the viewmodel property was dirty at the time of the attempted change.\r\n *  - once a new value has been assigned to a property of the viewmodel, that value will be returned during a read of that property in the future. However, the original model remain untouched until `submit()` is called.\r\n *\r\n * The viewmodel exposes the following additional methods, besides all the enumerable properties of the model:\r\n * - `submit()`: copies all the values of the viewmodel to the model and resets the state\r\n * - `reset()`: resets the state of the viewmodel, abandoning all local modifications\r\n * - `resetProperty(propName)`: resets the specified property of the viewmodel\r\n * - `isDirty`: observable property indicating if the viewModel contains any modifications\r\n * - `isPropertyDirty(propName)`: returns true if the specified property is dirty\r\n * - `changedValues`: returns a key / value map with the properties that have been changed in the model so far\r\n * - `model`: The original model object for which this viewModel was created\r\n *\r\n * You may use observable arrays, maps and objects with `createViewModel` but keep in mind to assign fresh instances of those to the viewmodel's properties, otherwise you would end up modifying the properties of the original model.\r\n * Note that if you read a non-dirty property, viewmodel only proxies the read to the model. You therefore need to assign a fresh instance not only the first time you make the assignment but also after calling `reset()` or `submit()`.\r\n *\r\n * @example\r\n * class Todo {\r\n *   \\@observable title = \"Test\"\r\n * }\r\n *\r\n * const model = new Todo()\r\n * const viewModel = createViewModel(model);\r\n *\r\n * autorun(() => console.log(viewModel.model.title, \",\", viewModel.title))\r\n * // prints \"Test, Test\"\r\n * model.title = \"Get coffee\"\r\n * // prints \"Get coffee, Get coffee\", viewModel just proxies to model\r\n * viewModel.title = \"Get tea\"\r\n * // prints \"Get coffee, Get tea\", viewModel's title is now dirty, and the local value will be printed\r\n * viewModel.submit()\r\n * // prints \"Get tea, Get tea\", changes submitted from the viewModel to the model, viewModel is proxying again\r\n * viewModel.title = \"Get cookie\"\r\n * // prints \"Get tea, Get cookie\" // viewModel has diverged again\r\n * viewModel.reset()\r\n * // prints \"Get tea, Get tea\", changes of the viewModel have been abandoned\r\n *\r\n * @param {T} model\r\n * @returns {(T & IViewModel<T>)}\r\n * ```\r\n */\r\nfunction createViewModel(model) {\r\n    return new ViewModel(model);\r\n}\n\n/**\r\n * MobX normally suspends any computed value that is not in use by any reaction,\r\n * and lazily re-evaluates the expression if needed outside a reaction while not in use.\r\n * `keepAlive` marks a computed value as always in use, meaning that it will always fresh, but never disposed automatically.\r\n *\r\n * @example\r\n * const obj = observable({\r\n *   number: 3,\r\n *   doubler: function() { return this.number * 2 }\r\n * })\r\n * const stop = keepAlive(obj, \"doubler\")\r\n *\r\n * @param {Object} target an object that has a computed property, created by `@computed` or `extendObservable`\r\n * @param {string} property the name of the property to keep alive\r\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\r\n */\r\n/**\r\n * @example\r\n * const number = observable(3)\r\n * const doubler = computed(() => number.get() * 2)\r\n * const stop = keepAlive(doubler)\r\n * // doubler will now stay in sync reactively even when there are no further observers\r\n * stop()\r\n * // normal behavior, doubler results will be recomputed if not observed but needed, but lazily\r\n *\r\n * @param {IComputedValue<any>} computedValue created using the `computed` function\r\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\r\n */\r\nfunction keepAlive(_1, _2) {\r\n    var computed = getAtom(_1, _2);\r\n    if (!computed)\r\n        throw new Error(\"No computed provided, please provide an object created with `computed(() => expr)` or an object + property name\");\r\n    return observe(computed, function () { });\r\n}\n\n/**\r\n * `queueProcessor` takes an observable array, observes it and calls `processor`\r\n * once for each item added to the observable array, optionally debouncing the action\r\n *\r\n * @example\r\n * const pendingNotifications = observable([])\r\n * const stop = queueProcessor(pendingNotifications, msg => {\r\n *   // show Desktop notification\r\n *   new Notification(msg);\r\n * })\r\n *\r\n * // usage:\r\n * pendingNotifications.push(\"test!\")\r\n *\r\n * @param {T[]} observableArray observable array instance to track\r\n * @param {(item: T) => void} processor action to call per item\r\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\r\n * @returns {IDisposer} stops the processor\r\n */\r\nfunction queueProcessor(observableArray, processor, debounce) {\r\n    if (debounce === void 0) { debounce = 0; }\r\n    if (!isObservableArray(observableArray))\r\n        throw new Error(\"Expected observable array as first argument\");\r\n    if (!isAction(processor))\r\n        processor = action(\"queueProcessor\", processor);\r\n    var runner = function () {\r\n        // construct a final set\r\n        var items = observableArray.slice(0);\r\n        // clear the queue for next iteration\r\n        runInAction(function () { return observableArray.splice(0); });\r\n        // fire processor\r\n        items.forEach(processor);\r\n    };\r\n    if (debounce > 0)\r\n        return autorun(runner, { delay: debounce });\r\n    else\r\n        return autorun(runner);\r\n}\n\n/**\r\n * `chunkProcessor` takes an observable array, observes it and calls `processor`\r\n * once for a chunk of items added to the observable array, optionally deboucing the action.\r\n * The maximum chunk size can be limited by number.\r\n * This allows both, splitting larger into smaller chunks or (when debounced) combining smaller\r\n * chunks and/or single items into reasonable chunks of work.\r\n *\r\n * @example\r\n * const trackedActions = observable([])\r\n * const stop = chunkProcessor(trackedActions, chunkOfMax10Items => {\r\n *   sendTrackedActionsToServer(chunkOfMax10Items);\r\n * }, 100, 10)\r\n *\r\n * // usage:\r\n * trackedActions.push(\"scrolled\")\r\n * trackedActions.push(\"hoveredButton\")\r\n * // when both pushes happen within 100ms, there will be only one call to server\r\n *\r\n * @param {T[]} observableArray observable array instance to track\r\n * @param {(item: T[]) => void} processor action to call per item\r\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\r\n * @param {number} [maxChunkSize=0] optionally do not call on full array but smaller chunks. With 0 it will process the full array.\r\n * @returns {IDisposer} stops the processor\r\n */\r\nfunction chunkProcessor(observableArray, processor, debounce, maxChunkSize) {\r\n    if (debounce === void 0) { debounce = 0; }\r\n    if (maxChunkSize === void 0) { maxChunkSize = 0; }\r\n    if (!isObservableArray(observableArray))\r\n        throw new Error(\"Expected observable array as first argument\");\r\n    if (!isAction(processor))\r\n        processor = action(\"chunkProcessor\", processor);\r\n    var runner = function () {\r\n        var _loop_1 = function () {\r\n            var chunkSize = maxChunkSize === 0\r\n                ? observableArray.length\r\n                : Math.min(observableArray.length, maxChunkSize);\r\n            // construct a final set\r\n            var items = observableArray.slice(0, chunkSize);\r\n            // clear the slice for next iteration\r\n            runInAction(function () { return observableArray.splice(0, chunkSize); });\r\n            // fire processor\r\n            processor(items);\r\n        };\r\n        while (observableArray.length > 0) {\r\n            _loop_1();\r\n        }\r\n    };\r\n    if (debounce > 0)\r\n        return autorun(runner, { delay: debounce });\r\n    else\r\n        return autorun(runner);\r\n}\n\nvar tickers = {};\r\n/**\r\n * Disposes of all the internal Observables created by invocations of `now()`.\r\n *\r\n * The use case for this is to ensure that unit tests can run independent of each other.\r\n * You should not call this in regular application code.\r\n *\r\n * @example\r\n * afterEach(() => {\r\n *     utils.resetNowInternalState()\r\n * })\r\n */\r\nfunction resetNowInternalState() {\r\n    for (var _i = 0, _a = Object.getOwnPropertyNames(tickers); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        tickers[key].dispose();\r\n        delete tickers[key];\r\n    }\r\n}\r\n/**\r\n * Returns the current date time as epoch number.\r\n * The date time is read from an observable which is updated automatically after the given interval.\r\n * So basically it treats time as an observable.\r\n *\r\n * The function takes an interval as parameter, which indicates how often `now()` will return a new value.\r\n * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a\r\n * `requestAnimationFrame` is available.\r\n *\r\n * Multiple clocks with the same interval will automatically be synchronized.\r\n *\r\n * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/\r\n *\r\n * @example\r\n *\r\n * const start = Date.now()\r\n *\r\n * autorun(() => {\r\n *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)\r\n * })\r\n *\r\n *\r\n * @export\r\n * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update\r\n * @returns\r\n */\r\nfunction now(interval) {\r\n    if (interval === void 0) { interval = 1000; }\r\n    if (!_isComputingDerivation()) {\r\n        // See #40\r\n        return Date.now();\r\n    }\r\n    if (!tickers[interval]) {\r\n        if (typeof interval === \"number\")\r\n            tickers[interval] = createIntervalTicker(interval);\r\n        else\r\n            tickers[interval] = createAnimationFrameTicker();\r\n    }\r\n    return tickers[interval].current();\r\n}\r\nfunction createIntervalTicker(interval) {\r\n    var subscriptionHandle;\r\n    return fromResource(function (sink) {\r\n        sink(Date.now());\r\n        subscriptionHandle = setInterval(function () { return sink(Date.now()); }, interval);\r\n    }, function () {\r\n        clearInterval(subscriptionHandle);\r\n    }, Date.now());\r\n}\r\nfunction createAnimationFrameTicker() {\r\n    var frameBasedTicker = fromResource(function (sink) {\r\n        sink(Date.now());\r\n        function scheduleTick() {\r\n            window.requestAnimationFrame(function () {\r\n                sink(Date.now());\r\n                if (frameBasedTicker.isAlive())\r\n                    scheduleTick();\r\n            });\r\n        }\r\n        scheduleTick();\r\n    }, function () { }, Date.now());\r\n    return frameBasedTicker;\r\n}\n\n/**\r\n *`expr` can be used to create temporary computed values inside computed values.\r\n * Nesting computed values is useful to create cheap computations in order to prevent expensive computations from needing to run.\r\n * In the following example the expression prevents that a component is rerender _each time_ the selection changes;\r\n * instead it will only rerenders when the current todo is (de)selected.\r\n *\r\n * `expr(func)` is an alias for `computed(func).get()`.\r\n * Please note that the function given to `expr` is evaluated _twice_ in the scenario that the overall expression value changes.\r\n * It is evaluated the first time when any observables it depends on change.\r\n * It is evaluated a second time when a change in its value triggers the outer computed or reaction to evaluate, which recreates and reevaluates the expression.\r\n *\r\n * In the following example, the expression prevents the `TodoView` component from being re-rendered if the selection changes elsewhere.\r\n * Instead, the component will only re-render when the relevant todo is (de)selected, which happens much less frequently.\r\n *\r\n * @example\r\n * const Todo = observer((props) => {\r\n *     const todo = props.todo\r\n *     const isSelected = mobxUtils.expr(() => props.viewState.selection === todo)\r\n * const TodoView = observer(({ todo, editorState }) => {\r\n *     const isSelected = mobxUtils.expr(() => editorState.selection === todo)\r\n *     return <div className={isSelected ? \"todo todo-selected\" : \"todo\"}>{todo.title}</div>\r\n * })\r\n */\r\nfunction expr(expr) {\r\n    if (!_isComputingDerivation())\r\n        console.warn(\"'expr' should only be used inside other reactive functions.\");\r\n    // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired\r\n    return computed(expr).get();\r\n}\n\nvar __assign$1 = (undefined && undefined.__assign) || function () {\r\n    __assign$1 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\nvar memoizationId = 0;\r\n/**\r\n * Creates a function that maps an object to a view.\r\n * The mapping is memoized.\r\n *\r\n * See the [transformer](#createtransformer-in-detail) section for more details.\r\n *\r\n * @param transformer\r\n * @param onCleanup\r\n */\r\nfunction createTransformer(transformer, arg2) {\r\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\r\n    // Memoizes: object id -> reactive view that applies transformer to the object\r\n    var views = {};\r\n    var onCleanup = undefined;\r\n    var keepAlive = false;\r\n    var debugNameGenerator = undefined;\r\n    if (typeof arg2 === \"object\") {\r\n        onCleanup = arg2.onCleanup;\r\n        keepAlive = arg2.keepAlive !== undefined ? arg2.keepAlive : false;\r\n        debugNameGenerator = arg2.debugNameGenerator;\r\n    }\r\n    else if (typeof arg2 === \"function\") {\r\n        onCleanup = arg2;\r\n    }\r\n    function createView(sourceIdentifier, sourceObject) {\r\n        var latestValue;\r\n        var computedValueOptions = {};\r\n        if (typeof arg2 === \"object\") {\r\n            onCleanup = arg2.onCleanup;\r\n            debugNameGenerator = arg2.debugNameGenerator;\r\n            computedValueOptions = arg2;\r\n        }\r\n        else if (typeof arg2 === \"function\") {\r\n            onCleanup = arg2;\r\n        }\r\n        else {\r\n            onCleanup = undefined;\r\n            debugNameGenerator = undefined;\r\n        }\r\n        var prettifiedName = debugNameGenerator\r\n            ? debugNameGenerator(sourceObject)\r\n            : \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier;\r\n        var expr = computed(function () {\r\n            return (latestValue = transformer(sourceObject));\r\n        }, __assign$1(__assign$1({}, computedValueOptions), { name: prettifiedName }));\r\n        if (!keepAlive) {\r\n            var disposer_1 = onBecomeUnobserved(expr, function () {\r\n                delete views[sourceIdentifier];\r\n                disposer_1();\r\n                if (onCleanup)\r\n                    onCleanup(latestValue, sourceObject);\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n    var memoWarned = false;\r\n    return function (object) {\r\n        var identifier = getMemoizationId(object);\r\n        var reactiveView = views[identifier];\r\n        if (reactiveView)\r\n            return reactiveView.get();\r\n        if (!keepAlive && !_isComputingDerivation()) {\r\n            if (!memoWarned) {\r\n                console.warn(\"invoking a transformer from outside a reactive context won't memorized \" +\r\n                    \"and is cleaned up immediately, unless keepAlive is set\");\r\n                memoWarned = true;\r\n            }\r\n            var value = transformer(object);\r\n            if (onCleanup)\r\n                onCleanup(value, object);\r\n            return value;\r\n        }\r\n        // Not in cache; create a reactive view\r\n        reactiveView = views[identifier] = createView(identifier, object);\r\n        return reactiveView.get();\r\n    };\r\n}\r\nfunction getMemoizationId(object) {\r\n    var objectType = typeof object;\r\n    if (objectType === \"string\")\r\n        return \"string:\" + object;\r\n    if (objectType === \"number\")\r\n        return \"number:\" + object;\r\n    if (object === null || (objectType !== \"object\" && objectType !== \"function\"))\r\n        throw new Error(\"[mobx-utils] transform expected an object, function, string or number, got: \" + String(object));\r\n    var tid = object.$transformId;\r\n    if (tid === undefined) {\r\n        tid = \"memoizationId:\" + ++memoizationId;\r\n        addHiddenProp(object, \"$transformId\", tid);\r\n    }\r\n    return tid;\r\n}\n\nfunction buildPath(entry) {\r\n    if (!entry)\r\n        return \"ROOT\";\r\n    var res = [];\r\n    while (entry.parent) {\r\n        res.push(entry.path);\r\n        entry = entry.parent;\r\n    }\r\n    return res.reverse().join(\"/\");\r\n}\r\nfunction isRecursivelyObservable(thing) {\r\n    return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);\r\n}\r\n/**\r\n * Given an object, deeply observes the given object.\r\n * It is like `observe` from mobx, but applied recursively, including all future children.\r\n *\r\n * Note that the given object cannot ever contain cycles and should be a tree.\r\n *\r\n * As benefit: path and root will be provided in the callback, so the signature of the listener is\r\n * (change, path, root) => void\r\n *\r\n * The returned disposer can be invoked to clean up the listener\r\n *\r\n * deepObserve cannot be used on computed values.\r\n *\r\n * @example\r\n * const disposer = deepObserve(target, (change, path) => {\r\n *    console.dir(change)\r\n * })\r\n */\r\nfunction deepObserve(target, listener) {\r\n    var entrySet = new WeakMap();\r\n    function genericListener(change) {\r\n        var entry = entrySet.get(change.object);\r\n        processChange(change, entry);\r\n        listener(change, buildPath(entry), target);\r\n    }\r\n    function processChange(change, parent) {\r\n        switch (change.type) {\r\n            // Object changes\r\n            case \"add\": // also for map\r\n                observeRecursively(change.newValue, parent, change.name);\r\n                break;\r\n            case \"update\": // also for array and map\r\n                unobserveRecursively(change.oldValue);\r\n                observeRecursively(change.newValue, parent, change.name || \"\" + change.index);\r\n                break;\r\n            case \"remove\": // object\r\n            case \"delete\": // map\r\n                unobserveRecursively(change.oldValue);\r\n                break;\r\n            // Array changes\r\n            case \"splice\":\r\n                change.removed.map(unobserveRecursively);\r\n                change.added.forEach(function (value, idx) {\r\n                    return observeRecursively(value, parent, \"\" + (change.index + idx));\r\n                });\r\n                // update paths\r\n                for (var i = change.index + change.addedCount; i < change.object.length; i++) {\r\n                    if (isRecursivelyObservable(change.object[i])) {\r\n                        var entry = entrySet.get(change.object[i]);\r\n                        if (entry)\r\n                            entry.path = \"\" + i;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    function observeRecursively(thing, parent, path) {\r\n        if (isRecursivelyObservable(thing)) {\r\n            var entry = entrySet.get(thing);\r\n            if (entry) {\r\n                if (entry.parent !== parent || entry.path !== path)\r\n                    // MWE: this constraint is artificial, and this tool could be made to work with cycles,\r\n                    // but it increases administration complexity, has tricky edge cases and the meaning of 'path'\r\n                    // would become less clear. So doesn't seem to be needed for now\r\n                    throw new Error(\"The same observable object cannot appear twice in the same tree,\" +\r\n                        (\" trying to assign it to '\" + buildPath(parent) + \"/\" + path + \"',\") +\r\n                        (\" but it already exists at '\" + buildPath(entry.parent) + \"/\" + entry.path + \"'\"));\r\n            }\r\n            else {\r\n                var entry_1 = {\r\n                    parent: parent,\r\n                    path: path,\r\n                    dispose: observe(thing, genericListener),\r\n                };\r\n                entrySet.set(thing, entry_1);\r\n                entries(thing).forEach(function (_a) {\r\n                    var key = _a[0], value = _a[1];\r\n                    return observeRecursively(value, entry_1, key);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    function unobserveRecursively(thing) {\r\n        if (isRecursivelyObservable(thing)) {\r\n            var entry = entrySet.get(thing);\r\n            if (!entry)\r\n                return;\r\n            entrySet.delete(thing);\r\n            entry.dispose();\r\n            values(thing).forEach(unobserveRecursively);\r\n        }\r\n    }\r\n    observeRecursively(target, undefined, \"\");\r\n    return function () {\r\n        unobserveRecursively(target);\r\n    };\r\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/**\r\n * Reactively sorts a base observable array into multiple observable arrays based on the value of a\r\n * `groupBy: (item: T) => G` function.\r\n *\r\n * This observes the individual computed groupBy values and only updates the source and dest arrays\r\n * when there is an actual change, so this is far more efficient than, for example\r\n * `base.filter(i => groupBy(i) === 'we')`. Call #dispose() to stop tracking.\r\n *\r\n * No guarantees are made about the order of items in the grouped arrays.\r\n *\r\n * The resulting map of arrays is read-only. clear(), set(), delete() are not supported and\r\n * modifying the group arrays will lead to undefined behavior.\r\n *\r\n * NB: ObservableGroupMap relies on `Symbol`s. If you are targeting a platform which doesn't\r\n * support these natively, you will need to provide a polyfill.\r\n *\r\n * @param {array} base The array to sort into groups.\r\n * @param {function} groupBy The function used for grouping.\r\n * @param options Object with properties:\r\n *  `name`: Debug name of this ObservableGroupMap.\r\n *  `keyToName`: Function to create the debug names of the observable group arrays.\r\n *\r\n * @example\r\n * const slices = observable([\r\n *     { day: \"mo\", hours: 12 },\r\n *     { day: \"tu\", hours: 2 },\r\n * ])\r\n * const slicesByDay = new ObservableGroupMap(slices, (slice) => slice.day)\r\n * autorun(() => console.log(\r\n *     slicesByDay.get(\"mo\")?.length ?? 0,\r\n *     slicesByDay.get(\"we\"))) // outputs 1, undefined\r\n * slices[0].day = \"we\" // outputs 0, [{ day: \"we\", hours: 12 }]\r\n */\r\nvar ObservableGroupMap = /** @class */ (function (_super) {\r\n    __extends(ObservableGroupMap, _super);\r\n    function ObservableGroupMap(base, groupBy, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? \"ogm\" + ((Math.random() * 1000) | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function (x) { return \"\" + x; } : _d;\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * Base observable array which is being sorted into groups.\r\n         */\r\n        Object.defineProperty(_this, \"_base\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        /**\r\n         * The ObservableGroupMap needs to track some state per-item. This is the name/symbol of the\r\n         * property used to attach the state.\r\n         */\r\n        Object.defineProperty(_this, \"_ogmInfoKey\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        /**\r\n         * The function used to group the items.\r\n         */\r\n        Object.defineProperty(_this, \"_groupBy\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        /**\r\n         * This function is used to generate the mobx debug names of the observable group arrays.\r\n         */\r\n        Object.defineProperty(_this, \"_keyToName\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(_this, \"_disposeBaseObserver\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        _this._keyToName = keyToName;\r\n        _this._groupBy = groupBy;\r\n        _this._ogmInfoKey = Symbol(\"ogmInfo\" + name);\r\n        _this._base = base;\r\n        for (var i = 0; i < base.length; i++) {\r\n            _this._addItem(base[i]);\r\n        }\r\n        _this._disposeBaseObserver = observe(_this._base, function (change) {\r\n            if (\"splice\" === change.type) {\r\n                transaction(function () {\r\n                    for (var _i = 0, _a = change.removed; _i < _a.length; _i++) {\r\n                        var removed = _a[_i];\r\n                        _this._removeItem(removed);\r\n                    }\r\n                    for (var _b = 0, _c = change.added; _b < _c.length; _b++) {\r\n                        var added = _c[_b];\r\n                        _this._addItem(added);\r\n                    }\r\n                });\r\n            }\r\n            else if (\"update\" === change.type) {\r\n                transaction(function () {\r\n                    _this._removeItem(change.oldValue);\r\n                    _this._addItem(change.newValue);\r\n                });\r\n            }\r\n            else {\r\n                throw new Error(\"illegal state\");\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"clear\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            throw new Error(\"not supported\");\r\n        }\r\n    });\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"delete\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (_key) {\r\n            throw new Error(\"not supported\");\r\n        }\r\n    });\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"set\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (_key, _value) {\r\n            throw new Error(\"not supported\");\r\n        }\r\n    });\r\n    /**\r\n     * Disposes all observers created during construction and removes state added to base array\r\n     * items.\r\n     */\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"dispose\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this._disposeBaseObserver();\r\n            for (var i = 0; i < this._base.length; i++) {\r\n                var item = this._base[i];\r\n                var grouperItemInfo = item[this._ogmInfoKey];\r\n                grouperItemInfo.reaction();\r\n                delete item[this._ogmInfoKey];\r\n            }\r\n        }\r\n    });\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"_getGroupArr\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (key) {\r\n            var result = _super.prototype.get.call(this, key);\r\n            if (undefined === result) {\r\n                result = observable([], { name: \"GroupArray[\" + this._keyToName(key) + \"]\", deep: false });\r\n                _super.prototype.set.call(this, key, result);\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"_removeFromGroupArr\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (key, itemIndex) {\r\n            var arr = _super.prototype.get.call(this, key);\r\n            if (1 === arr.length) {\r\n                _super.prototype.delete.call(this, key);\r\n            }\r\n            else if (itemIndex === arr.length - 1) {\r\n                // last position in array\r\n                arr.length--;\r\n            }\r\n            else {\r\n                arr[itemIndex] = arr[arr.length - 1];\r\n                arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;\r\n                arr.length--;\r\n            }\r\n        }\r\n    });\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"_addItem\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (item) {\r\n            var _this = this;\r\n            var groupByValue = this._groupBy(item);\r\n            var groupArr = this._getGroupArr(groupByValue);\r\n            var value = {\r\n                groupByValue: groupByValue,\r\n                groupArrIndex: groupArr.length,\r\n                reaction: reaction(function () { return _this._groupBy(item); }, function (newGroupByValue, _r) {\r\n                    var grouperItemInfo = item[_this._ogmInfoKey];\r\n                    _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\r\n                    var newGroupArr = _this._getGroupArr(newGroupByValue);\r\n                    var newGroupArrIndex = newGroupArr.length;\r\n                    newGroupArr.push(item);\r\n                    grouperItemInfo.groupByValue = newGroupByValue;\r\n                    grouperItemInfo.groupArrIndex = newGroupArrIndex;\r\n                }),\r\n            };\r\n            Object.defineProperty(item, this._ogmInfoKey, {\r\n                configurable: true,\r\n                enumerable: false,\r\n                value: value,\r\n            });\r\n            groupArr.push(item);\r\n        }\r\n    });\r\n    Object.defineProperty(ObservableGroupMap.prototype, \"_removeItem\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (item) {\r\n            var grouperItemInfo = item[this._ogmInfoKey];\r\n            this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\r\n            grouperItemInfo.reaction();\r\n            delete item[this._ogmInfoKey];\r\n        }\r\n    });\r\n    return ObservableGroupMap;\r\n}(ObservableMap));\n\n/**\r\n * @private\r\n */\r\nvar DeepMapEntry = /** @class */ (function () {\r\n    function DeepMapEntry(base, args) {\r\n        Object.defineProperty(this, \"base\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: base\r\n        });\r\n        Object.defineProperty(this, \"args\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: args\r\n        });\r\n        Object.defineProperty(this, \"root\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"closest\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"closestIdx\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: 0\r\n        });\r\n        Object.defineProperty(this, \"isDisposed\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: false\r\n        });\r\n        var current = (this.closest = this.root = base);\r\n        var i = 0;\r\n        for (; i < this.args.length - 1; i++) {\r\n            current = current.get(args[i]);\r\n            if (current)\r\n                this.closest = current;\r\n            else\r\n                break;\r\n        }\r\n        this.closestIdx = i;\r\n    }\r\n    Object.defineProperty(DeepMapEntry.prototype, \"exists\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this.assertNotDisposed();\r\n            var l = this.args.length;\r\n            return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]);\r\n        }\r\n    });\r\n    Object.defineProperty(DeepMapEntry.prototype, \"get\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this.assertNotDisposed();\r\n            if (!this.exists())\r\n                throw new Error(\"Entry doesn't exist\");\r\n            return this.closest.get(this.args[this.args.length - 1]);\r\n        }\r\n    });\r\n    Object.defineProperty(DeepMapEntry.prototype, \"set\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (value) {\r\n            this.assertNotDisposed();\r\n            var l = this.args.length;\r\n            var current = this.closest;\r\n            // create remaining maps\r\n            for (var i = this.closestIdx; i < l - 1; i++) {\r\n                var m = new Map();\r\n                current.set(this.args[i], m);\r\n                current = m;\r\n            }\r\n            this.closestIdx = l - 1;\r\n            this.closest = current;\r\n            current.set(this.args[l - 1], value);\r\n        }\r\n    });\r\n    Object.defineProperty(DeepMapEntry.prototype, \"delete\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this.assertNotDisposed();\r\n            if (!this.exists())\r\n                throw new Error(\"Entry doesn't exist\");\r\n            var l = this.args.length;\r\n            this.closest.delete(this.args[l - 1]);\r\n            // clean up remaining maps if needed (reconstruct stack first)\r\n            var c = this.root;\r\n            var maps = [c];\r\n            for (var i = 0; i < l - 1; i++) {\r\n                c = c.get(this.args[i]);\r\n                maps.push(c);\r\n            }\r\n            for (var i = maps.length - 1; i > 0; i--) {\r\n                if (maps[i].size === 0)\r\n                    maps[i - 1].delete(this.args[i - 1]);\r\n            }\r\n            this.isDisposed = true;\r\n        }\r\n    });\r\n    Object.defineProperty(DeepMapEntry.prototype, \"assertNotDisposed\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            // TODO: once this becomes annoying, we should introduce a reset method to re-run the constructor logic\r\n            if (this.isDisposed)\r\n                throw new Error(\"Concurrent modification exception\");\r\n        }\r\n    });\r\n    return DeepMapEntry;\r\n}());\r\n/**\r\n * @private\r\n */\r\nvar DeepMap = /** @class */ (function () {\r\n    function DeepMap() {\r\n        Object.defineProperty(this, \"store\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: new Map()\r\n        });\r\n        Object.defineProperty(this, \"argsLength\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: -1\r\n        });\r\n        Object.defineProperty(this, \"last\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n    }\r\n    Object.defineProperty(DeepMap.prototype, \"entry\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (args) {\r\n            if (this.argsLength === -1)\r\n                this.argsLength = args.length;\r\n            else if (this.argsLength !== args.length)\r\n                throw new Error(\"DeepMap should be used with functions with a consistent length, expected: \" + this.argsLength + \", got: \" + args.length);\r\n            if (this.last)\r\n                this.last.isDisposed = true;\r\n            return (this.last = new DeepMapEntry(this.store, args));\r\n        }\r\n    });\r\n    return DeepMap;\r\n}());\n\nvar __assign$2 = (undefined && undefined.__assign) || function () {\r\n    __assign$2 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$2.apply(this, arguments);\r\n};\r\nvar __spreadArrays$1 = (undefined && undefined.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n/**\r\n * computedFn takes a function with an arbitrary amount of arguments,\r\n * and memoizes the output of the function based on the arguments passed in.\r\n *\r\n * computedFn(fn) returns a function with the very same signature. There is no limit on the amount of arguments\r\n * that is accepted. However, the amount of arguments must be constant and default arguments are not supported.\r\n *\r\n * By default the output of a function call will only be memoized as long as the\r\n * output is being observed.\r\n *\r\n * The function passes into `computedFn` should be pure, not be an action and only be relying on\r\n * observables.\r\n *\r\n * Setting `keepAlive` to `true` will cause the output to be forcefully cached forever.\r\n * Note that this might introduce memory leaks!\r\n *\r\n * @example\r\n * const store = observable({\r\n    a: 1,\r\n    b: 2,\r\n    c: 3,\r\n    m: computedFn(function(x) {\r\n      return this.a * this.b * x\r\n    })\r\n  })\r\n\r\n  const d = autorun(() => {\r\n    // store.m(3) will be cached as long as this autorun is running\r\n    console.log(store.m(3) * store.c)\r\n  })\r\n *\r\n * @param fn\r\n * @param keepAliveOrOptions\r\n */\r\nfunction computedFn(fn, keepAliveOrOptions) {\r\n    if (keepAliveOrOptions === void 0) { keepAliveOrOptions = false; }\r\n    if (isAction(fn))\r\n        throw new Error(\"computedFn shouldn't be used on actions\");\r\n    var memoWarned = false;\r\n    var i = 0;\r\n    var opts = typeof keepAliveOrOptions === \"boolean\"\r\n        ? { keepAlive: keepAliveOrOptions }\r\n        : keepAliveOrOptions;\r\n    var d = new DeepMap();\r\n    return function () {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var entry = d.entry(args);\r\n        // cache hit, return\r\n        if (entry.exists())\r\n            return entry.get().get();\r\n        // if function is invoked, and its a cache miss without reactive, there is no point in caching...\r\n        if (!opts.keepAlive && !_isComputingDerivation()) {\r\n            if (!memoWarned && _getGlobalState().computedRequiresReaction) {\r\n                console.warn(\"invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set\");\r\n                memoWarned = true;\r\n            }\r\n            return fn.apply(this, args);\r\n        }\r\n        // create new entry\r\n        var latestValue;\r\n        var c = computed(function () {\r\n            return (latestValue = fn.apply(_this, args));\r\n        }, __assign$2(__assign$2({}, opts), { name: \"computedFn(\" + (opts.name || fn.name) + \"#\" + ++i + \")\" }));\r\n        entry.set(c);\r\n        // clean up if no longer observed\r\n        if (!opts.keepAlive)\r\n            onBecomeUnobserved(c, function () {\r\n                d.entry(args).delete();\r\n                if (opts.onCleanup)\r\n                    opts.onCleanup.apply(opts, __spreadArrays$1([latestValue], args));\r\n                latestValue = undefined;\r\n            });\r\n        // return current val\r\n        return c.get();\r\n    };\r\n}\n\nexport { FULFILLED, IDENTITY, NOOP, ObservableGroupMap, PENDING, REJECTED, ViewModel, addHiddenProp, chunkProcessor, computedFn, createTransformer, createViewModel, deepObserve, expr, fail, fromPromise, fromResource, fromStream, getAllMethodsAndProperties, invariant, isPromiseBasedObservable, keepAlive, lazyObservable, moveItem, now, queueProcessor, resetNowInternalState, toStream };\n"],
  "mappings": "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",
  "names": ["fromPromise", "_a", "StreamListener", "observable", "ViewModel", "computed", "expr", "keepAlive", "d", "b", "ObservableGroupMap", "_b", "_c", "DeepMapEntry", "DeepMap"]
}
